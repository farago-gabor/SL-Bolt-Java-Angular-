Rendben! NÃ©zzÃ¼k, hogyan kell mÃ³dosÃ­tani a **`TevekenysegServiceImpl`** osztÃ¡lyt, hogy tÃ¡mogassa az Ãºj `idopontok` struktÃºrÃ¡t (azaz: tÃ¶bb nap + tÃ¶bb idÅ‘pont tevÃ©kenysÃ©genkÃ©nt).

---

### âœ… ElÅ‘kÃ©szÃ¼let: HasznÃ¡lt osztÃ¡lyok

* DTO: `TevekenysegDTO` â tartalmaz `List<NapIdopontDTO>`
* EntitÃ¡s: `TevekenysegGyakorisag` â tartalmaz `List<TevekenysegIdopont>`

Mapperen keresztÃ¼l mÃ¡r tudjuk konvertÃ¡lni oda-vissza.

---

## ğŸ”§ 1. Ãšj tevÃ©kenysÃ©g lÃ©trehozÃ¡sa

### âœï¸ `ujTevekenyseg()` metÃ³dus frissÃ­tve:

```java
@Override
public void ujTevekenyseg(TevekenysegDTO dto) {
    Tevekenyseg tevekenyseg = new Tevekenyseg();
    tevekenyseg.setMegnevezes(dto.getMegnevezes());
    tevekenyseg.setLeiras(dto.getLeiras());
    tevekenysegRepository.save(tevekenyseg);

    TevekenysegGyakorisag gyak = new TevekenysegGyakorisag();
    gyak.setTevekenyseg(tevekenyseg);
    gyak.setGyakorisag(TevekenysegGyakorisag.Gyakorisag.valueOf(dto.getGyakorisag().toUpperCase()));
    gyak.setKezdoDatum(dto.getKezdoDatum());

    // Mapstruct segÃ­tsÃ©gÃ©vel alakÃ­tjuk DTO â†’ entitÃ¡s
    List<TevekenysegIdopont> idopontok = mapper.mapDTOsToIdopontok(dto.getIdopontok());
    // ÃllÃ­tsuk be a gyakorisÃ¡g kapcsolatot az idÅ‘pontokban is
    for (TevekenysegIdopont i : idopontok) {
        i.setGyakorisag(gyak);
    }

    gyak.setIdopontok(idopontok);
    gyakorisagRepository.save(gyak);
}
```

---

## ğŸ” 2. TevÃ©kenysÃ©g mÃ³dosÃ­tÃ¡sa

### âœï¸ `modositTevekenyseg()` metÃ³dus frissÃ­tve:

```java
@Override
public void modositTevekenyseg(int tevekenysegId, TevekenysegDTO dto) {
    Tevekenyseg tevekenyseg = tevekenysegRepository.findById(tevekenysegId)
            .orElseThrow(() -> new RuntimeException("TevÃ©kenysÃ©g nem talÃ¡lhatÃ³: " + tevekenysegId));

    tevekenyseg.setMegnevezes(dto.getMegnevezes());
    tevekenyseg.setLeiras(dto.getLeiras());
    tevekenysegRepository.save(tevekenyseg);

    TevekenysegGyakorisag gyak = gyakorisagRepository.findByTevekenyseg(tevekenyseg)
            .orElseThrow(() -> new RuntimeException("GyakorisÃ¡g nem talÃ¡lhatÃ³"));

    gyak.setGyakorisag(TevekenysegGyakorisag.Gyakorisag.valueOf(dto.getGyakorisag().toUpperCase()));
    gyak.setKezdoDatum(dto.getKezdoDatum());

    // ğŸ”„ TÃ¶rÃ¶ljÃ¼k a meglÃ©vÅ‘ idÅ‘pontokat Ã©s Ãºjakat Ã¡llÃ­tunk be
    gyak.getIdopontok().clear(); // csak ha CascadeType.ALL + orphanRemoval = true van beÃ¡llÃ­tva!
    List<TevekenysegIdopont> ujIdopontok = mapper.mapDTOsToIdopontok(dto.getIdopontok());
    for (TevekenysegIdopont i : ujIdopontok) {
        i.setGyakorisag(gyak);
    }
    gyak.setIdopontok(ujIdopontok);

    gyakorisagRepository.save(gyak);
}
```

> â˜ï¸ Fontos: az entitÃ¡sban a `@OneToMany(mappedBy = ..., cascade = CascadeType.ALL, orphanRemoval = true)` annotÃ¡ciÃ³k legyenek megfelelÅ‘en beÃ¡llÃ­tva a `TevekenysegGyakorisag` â†’ `TevekenysegIdopont` kapcsolatnÃ¡l.

---

## ğŸ—‘ï¸ 3. TÃ¶rlÃ©s: nincs vÃ¡ltozÃ¡s

A `torolTevekenyseg()` metÃ³dus nem igÃ©nyel mÃ³dosÃ­tÃ¡st, ha az entitÃ¡sok kÃ¶zt a cascade tÃ¶rlÃ©s rendben van.

---

## ğŸ“¥ 4. LekÃ©rdezÃ©s (Ã¶sszes, napi stb.)

Ezek mÃ¡r a `mapper.toTevekenysegDTO(...)` fÃ¼ggvÃ©nyt hasznÃ¡ljÃ¡k, tehÃ¡t az Ãºj `idopontok` mezÅ‘ automatikusan Ã¡tkerÃ¼l a DTO-ba.

---

## âœ… KÃ©szen vagyunk a service rÃ©teggel!

SzÃ³lj, ha szeretnÃ©d, hogy megnÃ©zzÃ¼k, hogyan jelenÃ­tsd meg ezt a frontenden (pl. Angularon), vagy ha kell egy rÃ¶vid teszt eset.
