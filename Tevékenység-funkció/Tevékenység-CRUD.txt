A Java Spring backend használatával a tevékenységek kezeléséhez és a formadatok mentéséhez szükséges entitásokat, DTO-kat és a megfelelő REST API-t kell létrehozni. Az alábbiakban bemutatom, hogyan nézne ki a backend oldali implementáció, ahol **JPA**, **MapStruct**, és **Lombok** segít a kód tisztán tartásában és az adatok kezelésében.

### 1. **Példa Entitások (JPA)**

#### `Activity` Entitás

Ez az entitás fogja reprezentálni a tevékenységeket az adatbázisban, és tartalmazza az összes szükséges mezőt.

```java
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class Activity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String activityName;
    private String description;
    
    @Column(nullable = false)
    private boolean isRegular;

    @Enumerated(EnumType.STRING)
    private Frequency frequency; // Heti, kéthetente, havi stb.

    @ElementCollection
    @CollectionTable(name = "activity_days", joinColumns = @JoinColumn(name = "activity_id"))
    @Column(name = "day")
    private List<String> selectedDays; // A napok listája (pl. Hétfő, Kedd, stb.)

    @ElementCollection
    @CollectionTable(name = "activity_time_points", joinColumns = @JoinColumn(name = "activity_id"))
    @Column(name = "time_point")
    private List<String> timePoints; // Időpontok (pl. "06:00", "07:00")

    private Integer interval; // Kéthetente / Havonta intervallum

    @Enumerated(EnumType.STRING)
    private IntervalType intervalType; // Kéthetente vagy havonta
}
```

* **`Frequency` Enum**: A tevékenység gyakoriságának meghatározásához.

```java
public enum Frequency {
    DAILY,
    WEEKLY,
    BIWEEKLY,
    MONTHLY,
    SPECIFIC
}
```

* **`IntervalType` Enum**: Az intervallum típusa (kéthetente, havonta).

```java
public enum IntervalType {
    BIWEEKLY,
    MONTHLY
}
```

#### `Activity` JPA Repository

A Spring Data JPA `Repository`-val könnyen kezelhetjük az adatbázist.

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface ActivityRepository extends JpaRepository<Activity, Long> {
}
```

### 2. **DTO-k és MapStruct**

A DTO-kat és a MapStruct használatát az adatok átalakítására használjuk az entitás és a front-end közötti kommunikációban. MapStruct segítségével könnyen átalakíthatjuk az entitásokat DTO-ká és vissza.

#### `ActivityDTO` (Data Transfer Object)

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ActivityDTO {
    private Long id;
    private String activityName;
    private String description;
    private boolean isRegular;
    private String frequency; // Enum string-ként
    private List<String> selectedDays;
    private List<String> timePoints;
    private Integer interval;
    private String intervalType; // Enum string-ként
}
```

#### `ActivityMapper` MapStruct interfész

A MapStruct segítségével automatikusan átalakíthatjuk az entitásokat és DTO-kat.

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

@Mapper
public interface ActivityMapper {

    ActivityMapper INSTANCE = Mappers.getMapper(ActivityMapper.class);

    @Mapping(source = "frequency", target = "frequency")
    @Mapping(source = "intervalType", target = "intervalType")
    ActivityDTO activityToActivityDTO(Activity activity);

    @Mapping(source = "frequency", target = "frequency")
    @Mapping(source = "intervalType", target = "intervalType")
    Activity activityDTOToActivity(ActivityDTO activityDTO);
}
```

### 3. **Service réteg**

A **Service** réteg az üzleti logikát tartalmazza, és itt hívjuk meg az adatbázist a `Repository`-n keresztül.

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ActivityService {

    private final ActivityRepository activityRepository;
    private final ActivityMapper activityMapper;

    @Autowired
    public ActivityService(ActivityRepository activityRepository, ActivityMapper activityMapper) {
        this.activityRepository = activityRepository;
        this.activityMapper = activityMapper;
    }

    public List<ActivityDTO> getAllActivities() {
        List<Activity> activities = activityRepository.findAll();
        return activities.stream()
                         .map(activityMapper::activityToActivityDTO)
                         .toList();
    }

    public ActivityDTO getActivityById(Long id) {
        Activity activity = activityRepository.findById(id)
                                               .orElseThrow(() -> new RuntimeException("Activity not found"));
        return activityMapper.activityToActivityDTO(activity);
    }

    public ActivityDTO saveActivity(ActivityDTO activityDTO) {
        Activity activity = activityMapper.activityDTOToActivity(activityDTO);
        Activity savedActivity = activityRepository.save(activity);
        return activityMapper.activityToActivityDTO(savedActivity);
    }

    public ActivityDTO updateActivity(Long id, ActivityDTO activityDTO) {
        Activity activity = activityRepository.findById(id)
                                               .orElseThrow(() -> new RuntimeException("Activity not found"));
        // Frissítés a DTO alapján
        activity.setActivityName(activityDTO.getActivityName());
        activity.setDescription(activityDTO.getDescription());
        activity.setFrequency(Frequency.valueOf(activityDTO.getFrequency()));
        activity.setSelectedDays(activityDTO.getSelectedDays());
        activity.setTimePoints(activityDTO.getTimePoints());
        activity.setInterval(activityDTO.getInterval());
        activity.setIntervalType(IntervalType.valueOf(activityDTO.getIntervalType()));
        
        Activity updatedActivity = activityRepository.save(activity);
        return activityMapper.activityToActivityDTO(updatedActivity);
    }

    public void deleteActivity(Long id) {
        Activity activity = activityRepository.findById(id)
                                               .orElseThrow(() -> new RuntimeException("Activity not found"));
        activityRepository.delete(activity);
    }
}
```

### 4. **Controller (REST API)**

A Spring MVC REST Controller segítségével exponálhatjuk az API-t, hogy a front-end kommunikálhasson a back-enddel.

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/activities")
public class ActivityController {

    private final ActivityService activityService;

    @Autowired
    public ActivityController(ActivityService activityService) {
        this.activityService = activityService;
    }

    @GetMapping
    public List<ActivityDTO> getAllActivities() {
        return activityService.getAllActivities();
    }

    @GetMapping("/{id}")
    public ActivityDTO getActivityById(@PathVariable Long id) {
        return activityService.getActivityById(id);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ActivityDTO createActivity(@RequestBody ActivityDTO activityDTO) {
        return activityService.saveActivity(activityDTO);
    }

    @PutMapping("/{id}")
    public ActivityDTO updateActivity(@PathVariable Long id, @RequestBody ActivityDTO activityDTO) {
        return activityService.updateActivity(id, activityDTO);
    }

    @DeleteMapping("/{id}")
    public void deleteActivity(@PathVariable Long id) {
        activityService.deleteActivity(id);
    }
}
```

### 5. **További konfigurációk**

* **Lombok**: Mivel a `@Data`, `@AllArgsConstructor`, `@NoArgsConstructor` és `@Builder` annotációkat használtuk, a Lombok automatikusan generálja a gettereket, settereket, `toString()` metódust, konstruktorokat, stb.

* **MapStruct**: A MapStruct segít a DTO-k és entitások közötti átalakítások automatizálásában, így csökkenthetjük a kód ismétlését.

### 6. **Adatbázis migrációk**

Az adatbázisban történő migrációkhoz használhatunk **Flyway** vagy **Liquibase** eszközöket, hogy az adatbázis struktúrája szinkronban maradjon a kódbázissal.

### Összegzés

* Az entitások `JPA` segítségével tárolják az adatokat.
* A **MapStruct** segítségével könnyen átalakíthatjuk az entitásokat DTO-ká.
* Az üzleti logika és az adatbázis kommunikáció a **Service** rétegben történik.
* A REST API az **ActivityController** osztályban van definiálva, és az Angular front-end ezen keresztül kommunikál a back-enddel.

Ez az architektúra tiszta, jól karbantartható és könnyen bővíthető.
