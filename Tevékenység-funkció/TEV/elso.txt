Nagyon j√≥ az adatmodell √©s a frontend koncepci√≥ ‚Äî **k√∂zel k√©sz**, de egy apr√≥ **kieg√©sz√≠t√©s** hi√°nyzik ahhoz, hogy val√≥ban helyesen kezeld azt az esetet, amikor **ugyanazt a tev√©kenys√©get t√∂bbsz√∂r is el kell v√©gezni ugyanazon a napon (pl. 6:00 √©s 14:00)**.

---

## üéØ A probl√©ma l√©nyege

A jelenlegi strukt√∫r√°ban a `tevekenyseg_naplo` t√°bla **csak a tev√©kenyseg_id**-t napl√≥zza.
Viszont, ha egy tev√©kenys√©ghez t√∂bb id≈ëpont is tartozik (`tevekenyseg_idopontok` t√°bla), akkor nem tudod **megk√ºl√∂nb√∂ztetni**, hogy a felhaszn√°l√≥ melyik id≈ëpontot pip√°lta ki (pl. reggeli vagy d√©lut√°ni).

---

## ‚úÖ Javasolt m√≥dos√≠t√°s

### 1Ô∏è‚É£ B≈ëv√≠tsd a `tevekenyseg_naplo` t√°bl√°t az `idopont_id` oszloppal

√çgy egy√©rtelm≈±en napl√≥zhat√≥, **melyik id≈ëpontban** t√∂rt√©nt a v√©grehajt√°s.

```sql
ALTER TABLE tevekenyseg_naplo
ADD COLUMN idopont_id INT NULL,
ADD FOREIGN KEY (idopont_id) REFERENCES tevekenyseg_idopontok(id) ON DELETE SET NULL;
```

> üß† Ez az oszlop akkor NULL, ha ‚Äûmindig‚Äù t√≠pus√∫ tev√©kenys√©gr≈ël van sz√≥ (vagyis nincs konkr√©t id≈ëpontja).

---

### 2Ô∏è‚É£ √çgy a napl√≥z√°s logik√°ja:

| tevekenyseg_id | idopont_id | dolgozo_id | datum               | megcsinalta |
| -------------- | ---------- | ---------- | ------------------- | ----------- |
| 3              | 10         | 2          | 2025-11-13 06:10:00 | 1           |
| 3              | 11         | 2          | 2025-11-13 14:05:00 | 1           |

‚Üí Egy nap **k√©tszer is megjelenhet ugyanaz a tev√©kenys√©g**, k√ºl√∂n sorban, az adott `idopont_id` alapj√°n.
√çgy a frontend k√∂nnyen kisz≈±rheti, hogy mely id≈ëpont(ok) maradt(ak) el.

---

## üñ•Ô∏è Backend lek√©rdez√©sek

### Mai elv√©gzend≈ë tev√©kenys√©gek lek√©r√©se

```sql
SELECT 
    t.id AS tevekenyseg_id,
    t.megnevezes,
    t.leiras,
    ig.idopont,
    ig.nap,
    tg.gyakorisag
FROM tevekenysegek t
JOIN tevekenyseg_gyakorisag tg ON tg.tevekenyseg_id = t.id
LEFT JOIN tevekenyseg_idopontok ig ON ig.gyakorisag_id = tg.id
WHERE
    (ig.nap = DAYNAME(CURDATE()) OR tg.gyakorisag = 'mindig')
```

### Mai elv√©gzettek lek√©r√©se

```sql
SELECT 
    t.megnevezes,
    d.nev AS dolgozoNev,
    n.datum,
    ig.idopont
FROM tevekenyseg_naplo n
JOIN tevekenysegek t ON n.tevekenyseg_id = t.id
LEFT JOIN dolgozok d ON n.dolgozo_id = d.id
LEFT JOIN tevekenyseg_idopontok ig ON n.idopont_id = ig.id
WHERE DATE(n.datum) = CURDATE() AND n.megcsinalta = TRUE;
```

---

## üß© Frontend oldali hat√°s

A `maiElvegzendo` t√∂mbbe most **minden id≈ëpont k√ºl√∂n sor** lesz, teh√°t pl.:

```ts
[
  { id: 3, megnevezes: 'Bolt nyit√°s', idopont: '06:00' },
  { id: 3, megnevezes: 'Bolt nyit√°s', idopont: '14:00' },
]
```

Amikor a dolgoz√≥ az ‚ÄûElv√©gezve‚Äù gombra kattint, a backend fel√© elk√ºld√∂d:

```json
{
  "tevekenyseg_id": 3,
  "idopont_id": 10
}
```

√âs ezt r√∂gz√≠ted a `tevekenyseg_naplo`-ban.

---

## üîí √ñsszegz√©s

| Funkci√≥                             | Megval√≥s√≠that√≥ a jelenlegi s√©m√°val? | Javasolt m√≥dos√≠t√°s                                   |
| ----------------------------------- | ----------------------------------- | ---------------------------------------------------- |
| Egy tev√©kenys√©g t√∂bb napi id≈ëpontja | ‚úÖ                                   | M√°r kezelted `tevekenyseg_idopontok` t√°bl√°val        |
| Napl√≥z√°s k√ºl√∂n id≈ëpontokra          | ‚ö†Ô∏è                                  | `idopont_id` mez≈ë hozz√°ad√°sa `tevekenyseg_naplo`-hoz |
| ‚ÄûMindig‚Äù t√≠pus√∫ tev√©kenys√©gek       | ‚úÖ                                   | `idopont_id` NULL marad                              |

---

Szeretn√©d, hogy mutassak egy konkr√©t **Node.js (Express)** backend endpoint p√©ld√°t is arra, hogyan napl√≥zza a front a ‚ÄûElv√©gezve‚Äù gombot (`POST /api/tevekenysegek/naplo`)?
