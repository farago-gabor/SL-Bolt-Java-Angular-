A feladat, hogy a dolgozók el tudják végezni a tevékenységeket, és ezeket a tevékenységeket nyilvántartsuk a naplóban. Rendszeres tevékenységek esetén pedig a gyakoriság alapján újra bekerüljenek a következő elvégzendő tevékenységek közé, amikor elérkezik az időpontjuk.

### Frontend

#### 1. **Tevékenység végrehajtásának kezelése**

A frontend-en lesz egy felület, ahol a dolgozók kiválaszthatják, hogy mely tevékenységeket végezték el, és a szükséges adatokat (pl. dátum, dolgozó) elküldhetik a backend felé. Ehhez egy egyszerű formot kell készíteni, amely tartalmazza a tevékenységek listáját, a végrehajtott tevékenységek kijelölését, és egy "Elvégezve" gombot.

#### Tevékenység végrehajtása frontend

1. **Tevékenységek listájának lekérése**

   * Kérjük le az összes tevékenységet a backendről.
   * A rendszeres tevékenységeknél figyelembe kell venni a gyakoriságot (pl. napi, heti).

2. **Tevékenységek végrehajtásának rögzítése**

3. **Következő elvégzendő tevékenységek generálása a rendszeres tevékenységek alapján.**

#### Frontend példakód (Angular)

##### **1. Tevékenységek megjelenítése**

```typescript
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, FormArray } from '@angular/forms';
import { ActivityService } from './activity.service';

@Component({
  selector: 'app-activity-log',
  templateUrl: './activity-log.component.html',
  styleUrls: ['./activity-log.component.css']
})
export class ActivityLogComponent implements OnInit {
  activityForm: FormGroup;
  activities: any[] = [];  // A tevékenységek listája
  completedActivities: any[] = [];  // Az elvégzett tevékenységek listája

  constructor(private fb: FormBuilder, private activityService: ActivityService) {}

  ngOnInit(): void {
    // 1. Tevékenységek lekérése
    this.activityService.getActivities().subscribe(data => {
      this.activities = data;
      this.initForm();
    });
  }

  // Form inicializálása
  initForm(): void {
    this.activityForm = this.fb.group({
      activities: this.fb.array(
        this.activities.map(activity => this.fb.control(false))  // Minden tevékenységhez egy checkbox
      )
    });
  }

  // Elvégezve tevékenység
  onSubmit(): void {
    const selectedActivities = this.getSelectedActivities();
    const completedActivities = selectedActivities.map(activity => ({
      activityId: activity.id,
      completedAt: new Date(),
      // Egyéb adatokat (pl. dolgozó ID) itt is hozzáadhatunk
    }));

    // 2. Tevékenységek végrehajtása a backend-en
    this.activityService.completeActivities(completedActivities).subscribe(response => {
      alert('Tevékenységek elvégezve');
      // Frissítés a listában: rendszeres tevékenységeket a megfelelő időpontokba helyezni
      this.updateNextActivities();
    });
  }

  // Kiválasztott tevékenységek lekérése
  getSelectedActivities(): any[] {
    return this.activityForm.value.activities
      .map((checked, index) => checked ? this.activities[index] : null)
      .filter(v => v !== null);
  }

  // Következő elvégzendő tevékenységek generálása
  updateNextActivities(): void {
    this.activityService.getNextActivities().subscribe(nextActivities => {
      // Rendszeres tevékenységek frissítése a következő elvégzendő listára
      console.log(nextActivities);
    });
  }
}
```

##### **2. Tevékenységek listájának megjelenítése és form**

```html
<form [formGroup]="activityForm" (ngSubmit)="onSubmit()">
  <div *ngFor="let activity of activities; let i = index">
    <input type="checkbox" [formControlName]="i" />
    {{ activity.activityName }} ({{ activity.frequency }})
  </div>

  <button type="submit" [disabled]="!activityForm.valid">Tevékenység elvégzése</button>
</form>
```

##### **3. Tevékenységek végrehajtásához szükséges szolgáltatás**

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ActivityService {

  private apiUrl = 'http://localhost:8080/api/activities';

  constructor(private http: HttpClient) {}

  // Tevékenységek lekérése
  getActivities(): Observable<any[]> {
    return this.http.get<any[]>(`${this.apiUrl}`);
  }

  // Tevékenységek végrehajtása
  completeActivities(activities: any[]): Observable<any> {
    return this.http.post(`${this.apiUrl}/complete`, activities);
  }

  // Következő elvégzendő tevékenységek lekérése
  getNextActivities(): Observable<any[]> {
    return this.http.get<any[]>(`${this.apiUrl}/next`);
  }
}
```

### Backend (Spring)

A backend-en a következő funkciókat kell megvalósítani:

1. **Tevékenységek végrehajtása és naplózása.**
2. **Rendszeres tevékenységek következő elvégzendő időpontjának meghatározása.**

#### **Tevékenység végrehajtása és naplózása**

A dolgozó elvégzi a tevékenységet, és ezt rögzíteni kell a naplóban. A `TevékenységNapló` entitás tárolja a végrehajtott tevékenységeket.

##### **TevékenységNapló Entitás**

```java
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.Date;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class ActivityLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "activity_id")
    private Activity activity;

    @ManyToOne
    @JoinColumn(name = "worker_id")
    private Worker worker;

    private Date completedAt;
}
```

##### **ActivityLogRepository**

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface ActivityLogRepository extends JpaRepository<ActivityLog, Long> {
}
```

##### **ActivityService**

A tevékenységek végrehajtásának és a rendszeres tevékenységek kezelésének logikája:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ActivityService {

    @Autowired
    private ActivityRepository activityRepository;

    @Autowired
    private ActivityLogRepository activityLogRepository;

    // Tevékenységek végrehajtása
    public void completeActivities(List<ActivityLog> activities) {
        // 1. Tevékenységek mentése a naplóba
        activityLogRepository.saveAll(activities);
        
        // 2. Frissítjük a következő elvégzendő tevékenységeket (ha rendszeres tevékenység)
        activities.forEach(activityLog -> {
            Activity activity = activityLog.getActivity();
            if (activity.isRegular()) {
                // 3. Frissítjük a következő elvégzendő időpontot (pl. heti, kéthetente, stb.)
                // logika, hogy mikor kell legközelebb elvégezni a tevékenységet
                updateNextScheduledActivity(activity);
            }
        });
    }

    private void updateNextScheduledActivity(Activity activity) {
        // Rendszeres tevékenységek frissítése
        // Pl. ha heti, akkor következő hétre, ha kéthetente, akkor a következő kétheti időpontra
        // Frissítjük a `nextScheduledAt` mezőt vagy egy új entitást hozunk létre
    }

    public List<Activity> getNextActivities() {
        // Visszaküldjük azokat a tevékenységeket, amelyek elvégzésre várnak a közeljövőben
        return activityRepository.findNextScheduledActivities();
    }
}
```

#### **ActivityController**

A REST API, amely kezeli a tevékenységek végrehajtását és a rendszeres tevékenységek frissítését.

```java
import org.springframework.beans.factory
```


.annotation.Autowired;
import org.springframework.web.bind.annotation.\*;

import java.util.List;

@RestController
@RequestMapping("/api/activities")
public class ActivityController {

```
@Autowired
private ActivityService activityService;

@PostMapping("/complete")
public void completeActivities(@RequestBody List<ActivityLog> activities) {
    activityService.completeActivities(activities);
}

@GetMapping("/next")
public List<Activity> getNextActivities() {
    return activityService.getNextActivities();
}
```

}

```

### Összegzés

1. **Frontend**: A tevékenységek végrehajtásakor a dolgozó kiválasztja, hogy mely tevékenységet végezte el. A frontend egy listát jelenít meg, ahol a dolgozó jelölheti a végrehajtott tevékenységeket, majd elküldi az adatokat a backend felé.
2. **Backend**: A backend a tevékenység végrehajtásának rögzítését és a következő elvégzendő tevékenységek számítását kezeli. Rendszeres tevékenységek esetén frissíti azok következő időpontját.
3. **Következő elvégzendő tevékenységek**: A backend az adatbázisban rögzíti a következő elvégzendő tevékenységeket, amelyek a megfelelő gyakoriság alapján kerülnek vissza a dolgozókhoz.

Ez a megoldás jól integrálható az előző backend és frontend kódokkal.
```
