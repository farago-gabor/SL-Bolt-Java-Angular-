Nagyszer≈±, akkor folytassuk a **JPA entit√°sok** √©s **DTO-k** m√≥dos√≠t√°s√°val √∫gy, hogy illeszkedjenek a kor√°bban megadott √∫j SQL strukt√∫r√°hoz, azaz hogy **egy tev√©kenys√©ghez t√∂bb (nap, id≈ëpont)** p√°rost tudjunk rendelni.

---

## ‚úÖ **1. √öJ entit√°s: `TevekenysegIdopont`**

Ez felel meg az √∫j SQL-t√°bl√°nak (`tevekenyseg_idopontok`):

```java
package hu.projekt.bolt.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "tevekenyseg_idopontok")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TevekenysegIdopont {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @ManyToOne
    @JoinColumn(name = "gyakorisag_id")
    private TevekenysegGyakorisag gyakorisag;

    private String nap;        // p√©ld√°ul: "hetfo", "kedd", stb.

    private String idopont;    // p√©ld√°ul: "07:00", "14:00"
}
```

---

## ‚úÖ **2. M√≥dos√≠tott `TevekenysegGyakorisag` entit√°s**

Mostant√≥l tartalmaz egy `List<TevekenysegIdopont>` mez≈ët:

```java
@OneToMany(mappedBy = "gyakorisag", cascade = CascadeType.ALL, orphanRemoval = true)
private List<TevekenysegIdopont> idopontok;
```

**Teljesen kib≈ëv√≠tett entit√°s:**

```java
@Entity
@Table(name = "tevekenyseg_gyakorisag")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TevekenysegGyakorisag {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @ManyToOne
    @JoinColumn(name = "tevekenyseg_id")
    private Tevekenyseg tevekenyseg;

    @Enumerated(EnumType.STRING)
    private Gyakorisag gyakorisag;

    private LocalDate kezdoDatum;

    @OneToMany(mappedBy = "gyakorisag", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TevekenysegIdopont> idopontok;

    public enum Gyakorisag {
        HETI,
        KETHETI,
        HAROMHETI,
        MINDIG,
        EGYSZERI
    }
}
```

---

## ‚úÖ **3. DTO: `TevekenysegDTO` m√≥dos√≠t√°sa**

Most nem `Map<String, String>`, hanem egy k√ºl√∂n lista a (nap, id≈ëpont) p√°roknak:

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TevekenysegDTO {

    private String megnevezes;
    private String leiras;
    private String gyakorisag;
    private LocalDate kezdoDatum;

    private List<NapIdopontDTO> idopontok;  // √∫j
}
```

---

### ‚úÖ `NapIdopontDTO` (√∫j DTO a p√°rokhoz)

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class NapIdopontDTO {
    private String nap;       // pl.: "hetfo"
    private String idopont;   // pl.: "07:00"
}
```

---

## üß≠ K√∂vetkez≈ë l√©p√©s:

Most m√°r a backend k√©pes t√∂bb (nap, id≈ëpont) p√°rt kezelni egy tev√©kenys√©gn√©l. A k√∂vetkez≈ë l√©p√©s a:

* ‚úÖ **MapStruct mapper** m√≥dos√≠t√°sa
* ‚úÖ **Service r√©teg** friss√≠t√©se (√∫j entit√°sok ment√©se, m√≥dos√≠t√°sa, t√∂rl√©se)

Ha szeretn√©d, folytathatjuk ezekkel is. Sz√≥lj, √©s j√∂n a mapper/friss√≠tett service k√≥d is.
