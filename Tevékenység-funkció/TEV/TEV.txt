Nagyon j√≥ k√©rd√©s ‚Äî √©s pontosan ez az a pont, ahol a **te jelenlegi adatmodell** majdnem t√∂k√©letes, csak **a napl√≥z√°si logik√°n** kell finom√≠tani.

√ñsszefoglalva:
üëâ Teh√°t **egy tev√©kenys√©ghez t√∂bb id≈ëpont** tartozhat (pl. 6:00, 14:00).
üëâ A dolgoz√≥ mindegyik id≈ëpontban **k√ºl√∂n-k√ºl√∂n** tudja elv√©gezni ugyanazt a tev√©kenys√©get.
üëâ Ez azt jelenti, hogy egy nap **t√∂bbsz√∂r is lehet napl√≥bejegyz√©s ugyanarra a tev√©kenys√©gre**, de **m√°s id≈ëpontokhoz k√∂tve**.

---

## üß± Alapelvek

Ezt **h√°rom r√©tegben** kell kezelni:

### 1Ô∏è‚É£ Adatb√°zis szinten ‚Äî egy√©rtelm≈±en azonos√≠that√≥ legyen az id≈ëpont

Ehhez az al√°bbi m√≥dos√≠t√°s sz√ºks√©ges (ha m√©g nem tetted meg):

```sql
ALTER TABLE tevekenyseg_naplo
ADD COLUMN idopont_id INT NULL,
ADD CONSTRAINT fk_naplo_idopont FOREIGN KEY (idopont_id)
    REFERENCES tevekenyseg_idopontok(id)
    ON DELETE SET NULL;
```

√çgy egy napl√≥bejegyz√©s pontosan jelzi:
‚û°Ô∏è melyik **tev√©kenys√©g**
‚û°Ô∏è melyik **id≈ëpont**
‚û°Ô∏è melyik **dolgoz√≥**
‚û°Ô∏è melyik **napon** t√∂rt√©nt.

---

### 2Ô∏è‚É£ Backend logika ‚Äî engedni kell, hogy *ugyanazon a napon t√∂bbsz√∂r is menthess√ºnk*, ha m√°s id≈ëpontr√≥l van sz√≥

Jelenleg n√°lad a k√≥dban ez van:

```java
boolean alreadyLogged = naploRepository.existsByTevekenysegAndDatum(tevekenyseg, datum);
if (alreadyLogged) return;
```

Ez **blokkolja** a t√∂bbsz√∂ri napi v√©grehajt√°st.
M√≥dos√≠tsd √≠gy:

```java
boolean alreadyLogged = naploRepository.existsByTevekenysegAndIdopontAndDatum(tevekenyseg, idopont, datum);
if (alreadyLogged) return;
```

> Ezzel csak akkor tiltod a m√°sodik ment√©st, ha *ugyanazt az id≈ëpontot* pr√≥b√°lja √∫jra elv√©gezni aznap.

---

### 3Ô∏è‚É£ Repository kieg√©sz√≠t√©s

A `TevekenysegNaploRepository`-ban legyen ez a met√≥dus:

```java
boolean existsByTevekenysegAndIdopontAndDatum(Tevekenyseg tevekenyseg, TevekenysegIdopont idopont, LocalDate datum);
```

Ezen k√≠v√ºl a mai nap lek√©rdez√©s√©hez (ami a ‚ÄûMai elv√©gzettek‚Äù t√°bl√°t t√∂lti) j√≥, ha van:

```java
List<TevekenysegNaplo> findAllByDatum(LocalDate datum);
```

---

### 4Ô∏è‚É£ Service m√≥dos√≠t√°s (`feladatElvegzese`)

A m√°r l√°tott verzi√≥ pontosan erre k√©sz√ºlt:

```java
@Override
public void feladatElvegzese(int tevekenysegId, Integer idopontId, int dolgozoId, LocalDate datum) {
    Tevekenyseg tevekenyseg = tevekenysegRepository.findById(tevekenysegId)
            .orElseThrow(() -> new RuntimeException("Tev√©kenys√©g nem tal√°lhat√≥: " + tevekenysegId));

    Dolgozo dolgozo = dolgozoRepository.findById(dolgozoId)
            .orElseThrow(() -> new RuntimeException("Dolgoz√≥ nem tal√°lhat√≥: " + dolgozoId));

    TevekenysegIdopont idopont = null;
    if (idopontId != null) {
        idopont = idopontRepository.findById(idopontId)
                .orElseThrow(() -> new RuntimeException("Id≈ëpont nem tal√°lhat√≥: " + idopontId));
    }

    boolean alreadyLogged = naploRepository.existsByTevekenysegAndIdopontAndDatum(tevekenyseg, idopont, datum);
    if (alreadyLogged) return;

    TevekenysegNaplo naplo = new TevekenysegNaplo();
    naplo.setTevekenyseg(tevekenyseg);
    naplo.setIdopont(idopont);
    naplo.setDolgozo(dolgozo);
    naplo.setDatum(datum);
    naplo.setMegcsinalta(true);

    naploRepository.save(naplo);
}
```

---

### 5Ô∏è‚É£ Frontend oldalon ‚Äî minden id≈ëpont k√ºl√∂n ‚ÄûElv√©gezve‚Äù gombot kap

Ha egy tev√©kenys√©ghez t√∂bb id≈ëpont tartozik, a frontendben az `idopontok` t√∂mb alapj√°n gener√°lhatsz t√∂bb sort vagy t√∂bb gombot:

```html
<mat-cell *matCellDef="let t">
  <ng-container *ngFor="let i of t.idopontok">
    <button mat-raised-button color="primary" (click)="elvegzes(t.id, i.id)">
      {{ i.idopont }} ‚Äì Elv√©gezve
    </button>
  </ng-container>
</mat-cell>
```

√âs az Angular komponensben:

```ts
elvegzes(tevekenysegId: number, idopontId: number | null) {
  this.http.post('/api/tevekenysegek/naplo', {
    tevekenysegId,
    idopontId,
    dolgozoId: this.loggedInUserId
  }).subscribe(() => this.frissit());
}
```

---

## üí° √ñsszefoglalva

| R√©teg          | Teend≈ë                                         | C√©l                                  |
| -------------- | ---------------------------------------------- | ------------------------------------ |
| **Adatb√°zis**  | `tevekenyseg_naplo` t√°bl√°hoz `idopont_id` mez≈ë | Lehessen k√ºl√∂n id≈ëpontot napl√≥zni    |
| **Repository** | `existsByTevekenysegAndIdopontAndDatum`        | Csak ugyanazt az id≈ëpontot blokkolja |
| **Service**    | Ellen≈ërz√©s kieg√©sz√≠t√©se + `idopont` kezel√©se   | T√∂bb id≈ëpont ‚Üí t√∂bb bejegyz√©s        |
| **Frontend**   | Minden id≈ëpontra k√ºl√∂n gomb                    | T√∂bbsz√∂ri napi elv√©gz√©s              |

---

üëâ Ezzel a megold√°ssal a rendszer k√©pes lesz:

* ugyanazt a feladatot **t√∂bbsz√∂r is napl√≥zni ugyanazon a napon**, ha t√∂bb id≈ëpont tartozik hozz√°,
* viszont **nem** fogja k√©tszer engedni ugyanazt az id≈ëpontot kipip√°lni.

---

Szeretn√©d, hogy megmutassam, **hogyan kell kin√©znie a `TevekenysegIdopontRepository` √©s `TevekenysegNaploRepository`** k√≥dnak pontosan (Spring Data JPA interf√©sz szinten)?
